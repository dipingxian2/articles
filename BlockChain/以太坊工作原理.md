# How does Ethereum work, anyway?
引自：http://blog.csdn.net/taifei/article/details/78225145

## 简介

不管你们知不知道以太坊（Ethereum blockchain）是什么，但是你们大概都听说过以太坊。最近在新闻里出现过很多次，包括一些专业杂志的封面，但是如果你们对以太坊到底是什么没有一个基本的了解的话，看这些文章就会感觉跟看天书一样。 所以，什么是以太坊？本质上，就是一个保存数字交易永久记录的公共数据库。重要的是，这个数据库不需要任何中央权威机构来维持和保护它。相反的它以一个“无信任”的交易系统来运行—一个个体在不需要信任任何第三方或对方的情况下进行点对点交易的架构。

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110601133046.jpeg)

依然感到很困惑？这就是这篇文章存在的理由。我的目标是在技术层面来解释以太坊的工作原理，但是不会出现很复杂的数学问题或看起来很可怕的公式。即使你不是一个程序员，我希望你看完之后最起码对技术有个更好的认识。如果有些部分技术性太强不好理解，这是非常正常的，真的没有必要完全理解每一个小细节。我建议只要宏观的理解一下事物就行了。

这篇文章中的很多议点都是以太坊黄皮书中讨论过的概念的细分。我添加了我自己的解释和图表使理解以太坊更加简单一点。那些足够勇敢的人可以挑战一下技术，去阅读一下以太坊的黄皮书。

好了， 让我们开始吧！

## 区块链定义

区块链就是一个具有共享状态的密码性安全交易的单机(cryptographically secure transactional singleton machine with shared-state)。[1]这有点长，是吧？让我们将它分开来看：

1. “密码性安全(Cryptographically secure)”是指用一个很难被解开的复杂数学机制算法来保证数字货币生产的安全性。将它想象成类似于防火墙的这种。它们使得欺骗系统近乎是一个不可能的事情（比如：构造一笔假的交易，消除一笔交易等等）。

2. “交易的单机(Transactional singleton machine)”是指只有一个权威的机器实例为系统中产生的交易负责任。换句话说，只有一个全球真相是大家所相信的。

3. “具有共享状态(With shared-state)”是指在这台机器上存储的状态是共享的，对每个人都是开放的。
以太坊实现了区块链的这个范例。

## 以太坊模型说明
以太坊的本质就是一个基于交易的状态机(transaction-based state machine)。在计算机科学中，一个 状态机 是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606138940.png)

根据以太坊的状态机，我们从创世纪状态(genesis state)开始。这差不多类似于一片空白的石板，在网络中还没有任何交易的产生状态。当交易被执行后，这个创世纪状态就会转变成最终状态。在任何时刻，这个最终状态都代表着以太坊当前的状态。

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606167787.png)

以太坊的状态有百万个交易。这些交易都被“组团”到一个区块中。一个区块包含了一系列的交易，每个区块都与它的前一个区块链接起来。

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606197936.png)

为了让一个状态转换成下一个状态，交易必须是有效的。为了让一个交易被认为是有效的，它必须要经过一个验证过程，此过程也就是挖矿。挖矿就是一组节点（即电脑）用它们的计算资源来创建一个包含有效交易的区块出来。

任何在网络上宣称自己是矿工的节点都可以尝试创建和验证区块。世界各地的很多矿工都在同一时间创建和验证区块。每个矿工在提交一个区块到区块链上的时候都会提供一个数学机制的“证明”，这个证明就像一个保证：如果这个证明存在，那么这个区块一定是有效的。

为了让一个区块添加到主链上，一个矿工必须要比其他矿工更快的提供出这个“证明”。通过矿工提供的一个数学机制的“证明”来证实每个区块的过程称之为工作量证明(proof of work)。

证实了一个新区块的矿工都会被奖励一定价值的奖赏。奖赏是什么？以太坊使用一种内在数字代币—以太币(Ether)作为奖赏。每次矿工证明了一个新区块，那么就会产生一个新的以太币并被奖励给矿工。

你也许会在想：什么能确保每个人都只在区块的同一条链上呢？我们怎么能确定不会存在一部分矿工创建一个他们自己的链呢？

前面，我们定义了区块链就是一个具有共享状态的交易单机。使用这个定义，我们可以知道正确的当前状态是一个全球真相，所有人都必须要接受它。拥有多个状态（或多个链）会摧毁这个系统，因为它在哪个是正确状态的问题上不可能得到统一结果。如果链分叉了，你有可能在一条链上拥有10个币，一条链上拥有20个币，另一条链上拥有40个币。在这种场景下，是没有办法确定哪个链才是最”有效的“。

不论什么时候只要多个路径产生了，一个”分叉“就会出现。我们通常都想避免分叉，因为它们会破坏系统，强制人们去选择哪条链是他们相信的链。

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606222966.png)

为了确定哪个路径才是最有效的以及防止多条链的产生，以太坊使用了一个叫做“GHOST协议(GHOST protocol.)”的数学机制。

`GHOST = Greedy Heaviest Observed Subtree`

简单来说，GHOST协议就是让我们必须选择一个在其上完成计算最多的路径。一个方法确定路径就是使用最近一个区块（叶子区块）的区块号，区块号代表着当前路径上总的区块数（不包含创世纪区块）。区块号越大，路径就会越长，就说明越多的挖矿算力被消耗在此路径上以达到叶子区块。使用这种推理就可以允许我们赞同当前状态的权威版本

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606255730.png）

现在你大概对区块链是什么有个理性的认识，让我们在再深入了地解一下以太坊系统主要组成部分：

1.账户(accounts)
2.状态(state)
3.损耗和费用(gas and fees)
4.交易(transactions)
5.区块(blocks)
6.交易执行(transaction execution)
7.挖矿(mining)
8.工作量证明(proof of work)
在开始之前需要注意的是：每当我说某某的hash， 我指的都是KECCAK-256 hash, 以太坊就是使用这个hash算法。

#### 账户
以太坊的全局“共享状态”是有很多小对象（账户）来组成的，这些账户可以通过消息传递架构来与对方进行交互。每个账户都有一个与之关联的状态(state)和一个20字节的地址(address)。在以太坊中一个地址是160位的标识符，用来识别账户的。

一共有两种类型的账户：

1.外部拥有的账户，被私钥控制且没有任何代码与之关联
2.合约账户，被它们的合约代码控制且有代码与之关联

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606289258.png)

##### 外部拥有账户与合约账户的比较
理解外部拥有账户和合约账户的基本区别是很重要的。一个外部拥有账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户。在两个外部拥有账户之间传送的消息只是一个简单的价值转移。但是从外部拥有账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。

不像外部拥有账户，合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户接)，为了响应此交易而触发一个交易。我们将会在“交易和消息”部分来了解关于合约与合约之间的通信。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606315694.png)

因此，在以太坊上任何的动作，总是被外部控制账户触发的交易所发动的。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606346364.png)

##### 账户状态
账户状态有四个组成部分，不论账户类型是什么，都存在这四个组成部分：
nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号
balance： 此地址拥有Wei的数量。1Ether=10^18Wei
storageRoot： Merkle Patricia树的根节点Hash值（我们后面在解释Merkle树）。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值
codeHash：此账户EVM（以太坊虚拟机，后面细说）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606371715.png)

###### 世界状态
好了，我们知道了以太坊的全局状态就是由账户地址和账户状态的一个映射组成。这个映射被保存在一个叫做Merkle Patricia树的数据结构中

Merkle Tree（也被叫做Merkle trie 默克尔树）是一种由一系列节点组成的二叉树，这些节点包括：

在树底的包含了源数据的大量叶子节点
一系列的中间的节点，这些节点是两个子节点的Hash值
一个根节点，同样是两个子节点的Hash值，代表着整棵树
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606401534.png)
树底的数据是通过分开我们想要保存到chunks的数据产生的，然后将chunks分成buckets，再然后再获取每个bucket的hash值并一直重复直到最后只剩下一个Hash：根Hash。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606434066.png)
这棵树要求存在里面的值（value）都有一个对应的key。从树的根节点开始，key会告诉你顺着哪个子节点可以获得对应的值，这个值存在叶子节点。在以太坊中，key/value是地址和与地址相关联的账户之间状态的映射，包括每个账户的balance, nonce, codeHash和storageRoot（storageRoot自己就是一颗树）。

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606473275.png)

同样的树结构也用来存储交易和收据。更具体的说，每个块都有一个头(header)，保存了三个不同Merkle trie结构的根节点的Hash，包括：
1.状态树
2.交易树
3.收据树
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606499560.png)

在Merkle tries中存储所有信息的高效性在以太坊中的“轻客户端”和“轻节点”相当的有用。记住区块链就是一群节点来维持的。广泛的说，有两种节点类型：全节点和轻节点。

全节点通过下载整条链来进行同步，从创世纪块到当前块，执行其中包含的所有交易。通常，矿工会存储全节点，因为他们在挖矿过程中需要全节点。也有可能下载一个全节点而不用执行所有的交易。无论如何，一个全节点包含了整个链。

不过除非一个节点需要执行所有的交易或轻松访问历史数据，不然没必要保存整条链。这就是轻节点概念的来源。比起下载和存储整个链以及执行其中所有的交易，轻节点仅仅下载链的头，从创世纪块到当前块的头，不执行任何的交易或检索任何相关联的状态。由于轻节点可以访问块的头，而头中包含了3个tries的Hash，所有轻节点依然可以很容易生成和接收关于交易、事件、余额等可验证的答案。

这个可以行的通是因为在Merkle树中hash值是向上传播的—如果一个恶意用户试图用一个假交易来交换Merkle树底的交易，这个会改变它上面节点的hash值，而它上面节点的值的改变也会导致上上一个节点Hash值的改变，以此类推，一直到树的根节点。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606527794.png)

任何节点想要验证一些数据都可以通过Merkle证明来进行验证，Merkle 证明的组成：
1.一块需要验证的数据
2.树的根节点Hash
3.一个“分支”（从 chunk到根这个路径上所有的hash值）
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606554551.png)
任何可以读取证明的人都可以验证分支的hash是连贯的，因此给出的块在树中实际的位置就是在此处。

总之，使用Merkle Patricia树的好处就是该结构的根节点加密取决于存储在树中的数据，而且根据点的hash还可以作为该数据的安全标识。由于块的头包含了状态、交易、收据树的根hash，所有任何节点都可以验证以太坊的一小部分状态而不用保存整个状态，这整个状态的的大小可能是非常大的。

##### Gas和费用

在以太坊中一个比较重要的概念就是费用(fees)，由以太坊网络上的交易而产生的每一次计算，都会产生费用—没有免费的午餐。这个费用是以称之为”gas”的来支付。
gas就是用来衡量在一个具体计算中要求的费用单位。gas price就是你愿意在每个gas上花费Ether的数量，以“gwei”进行衡量。“Wei”是Ether的最小单位，1Ether表示10^18Wei. 1gwei是1,000,000,000 Wei。

对每个交易，发送者设置gas limit和gas price。gas limit和gas price就代表着发送者愿意为执行交易支付的Wei的最大值。

例如，假设发送者设置gas limit为50,000，gas price为20gwei。这就表示发送者愿意最多支付50,000*20gwei = 1,000,000,000,000,000 Wei = 0.001 Ether来执行此交易。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110606591183.png)
记住gas limit代表用户愿意花费在gas上的钱的最大值。如果在他们的账户余额中有足够的Ether来支付这个最大值费用，那么就没问题。在交易结束时任何未使用的gas都会被返回给发送者，以原始费率兑换。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607027132.png)

这些gas的钱到底去了哪里？发送者在gas上花费的所有钱都发送给了“受益人”地址，通常情况下就是矿工的地址。因为矿工为了计算和验证交易做出了努力，所以矿工接收gas的费用作为奖励。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607074702.png)

通常，发送者愿意支付更高的gas price，矿工从这笔交易总就能获得更多的价值。因此，矿工也就更加愿意选择这笔交易。这样的话，矿工可以自由的选择一笔交易自己愿意验证或忽略。为了引导发送者应该设置gas price为多少，矿工可以选择建议一个最小的gas值他们愿意执行一个交易。

##### 存储也有费用
gas不仅仅是用来支付计算这一步的费用，而且也用来支付存储的费用。存储的总费用与所使用的32位字节的最小倍数成比例。

存储费用有一些比较细微的方面。比如，由于增加了的存储增加了所有节点上的以太坊状态数据库的大小，所以激励保持数据存储量小。为了这个原因，如果一个交易的执行有一步是清除一个存储实体，那么为执行这个操作的费用就会被放弃，并且由于释放存储空间的退款就会被返回给发送者。

##### 费用的作用是什么？
以太坊可以运作的一个重要方面就是每个网络执行的操作同时也被全节点所影响。然而，计算的操作在以太坊虚拟机上是非常昂贵的。因此，以太坊智能合约最好是用来执行最简单的任务，比如运行一个简单的业务逻辑或者验证签名和其他密码对象，而不是用于复杂的操作，比如文件存储，电子邮件，或机器学习，这些会给网络造成压力。施加费用防止用户使网络超负荷。

以太坊是一个图灵完备语言（短而言之，图灵机器就是一个可以模拟任何电脑算法的机器。对于图灵机器不太熟悉的人可以看看这个 和这个 ）。这就允许有循环，并使以太坊受到停机问题 的影响，这个问题让你无法确定程序是否无限制的运行。如果没有费用的话，恶意的执行者通过执行一个包含无限循环的交易就可以很容易的让网络瘫痪而不会产生任何反响。因此，费用保护网络不受蓄意攻击。

你也许会想，“为什么我们还需要为存储付费？”其实就像计算一样，以太坊网络上的存储是整个网络都必须要负担的成本。

##### 交易和消息
之前说过以太坊是一个基于交易的状态机。换句话说，在两个不同账户之间发生的交易才让以太坊全球状态从一个状态转换成另一个状态。

最基本的概念，一个交易就是被外部拥有账户生成的加密签名的一段指令，序列化，然后提交给区块链。

有两种类型的交易：消息通信和合约创建(也就是交易产生一个新的以太坊合约)。

不管什么类型的交易，都包含：
1. nonce：发送者发送交易数的计数
2. gasPrice：发送者愿意支付执行交易所需的每个gas的Wei数量
3. gasLimit：发送者愿意为执行交易支付gas数量的最大值。这个数量被设置之后在任何计算完成之前就会被提前扣掉
4. to：接收者的地址。在合约创建交易中，合约账户的地址还没有存在，所以值先空着
5. value：从发送者转移到接收者的Wei数量。在合约创建交易中，value作为新建合约账户的开始余额
6. v,r,s：用于产生标识交易发生着的签名
7. init（只有在合约创建交易中存在）：用来初始化新合约账户的EVM代码片段。init值会执行一次，然后就会被丢弃。当init第一次执行的时候，它返回一个账户代码体，也就是永久与合约账户关联的一段代码。
8. data（可选域，只有在消息通信中存在）：消息通话中的输入数据(也就是参数)。例如，如果智能合约就是一个域名注册服务，那么调用合约可能就会期待输入域例如域名和IP地址

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607104479.png)

在“账户”这个章节中我们学到交易—消息通信和合约创建交易两者都总是被外部拥有账户触发并提交到区块链的。换种思维思考就是，交易是外部世界和以太坊内部状态的桥梁。

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607149106.png)

但是这也并不代表一个合约与另一个合约无法通信。在以太坊状态全局范围内的合约可以与在相同范围内的合约进行通信。他们是通过“消息”或者“内部交易”进行通信的。我们可以认为消息或内部交易类似于交易，不过与交易有着最大的不同点—它们不是由外部拥有账户产生的。相反，他们是被合约产生的。它们是虚拟对象，与交易不同，没有被序列化而且只存在与以太坊执行环境。

当一个合约发送一个内部交易给另一个合约，存在于接收者合约账户相关联的代码就会被执行。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607179673.png)
一个重要需要注意的事情是内部交易或者消息不包含gasLimit。因为gas limit是由原始交易的外部创建者决定的（也就是外部拥有账户）。外部拥有账户设置的gas limit必须要高到足够将交易完成，包括由于此交易而长生的任何”子执行”，例如合约到合约的消息。如果，在一个交易或者信息链中，其中一个消息执行使gas已不足，那么这个消息的执行会被还原，包括任何被此执行触发的子消息。不过，父执行没必要被还原。

#### 区块
所有的交易都被组成一个”块”。一个区块链包含了一系列这样的链在一起区块。

在以太坊中，一个区块包含：

区块头
关于包含在此区块中交易集的信息
与当前块的ommers相关的一系列其他区块头

##### Ommers解释
“ommer”到底是什么？ ommer就是一个区块的父区块与当前区块父区块的父区块是相同的。让我们快速了解一下ommers是用来干嘛的，并且为什么一个区块需要为ommers包含区块头。

由于以太坊的构造，它的区块生产时间（大概15秒左右）比其他的区块链例如Bitcoin（大概10分钟左右）要快很多。这使得交易的处理更快。但是，更短的区块生产时间的一个缺点就是：更多的竞争区块会被矿工发现。这些竞争区块同样也被称为“孤区块”（也就是被挖出来但是不会被添加到主链上的区块）。

Ommers的目的就是为了帮助奖励矿工纳入这些孤区块。矿工包含的ommers必须是有效的，也就是ommers必须在父区块的第6个子区块之内或更小范围内。在第6个子区块之后，陈旧的孤区块将不会再被引用（因为包含老旧的交易会使事情变得复杂一点）。

Ommer区块会收到比全区块少一点的奖励。不管怎样，依然存在激励来让矿工们纳入孤区块并能从中获得一些报酬。

##### 区块头
让我们再回到区块的问题上。我们前面提到每个区块都有一个“区块头”，但这究竟是什么？

区块头是一个区块的一部分，包含了：

1.parentHash：父区块头的Hash值（这也是使得区块变成区块链的原因）
2.ommerHash：当前区块ommers列表的Hash值
3.beneficiary：接收挖此区块费用的账户地址
4.stateRoot：状态树根节点的Hash值（回忆一下我们之前所说的保存在头中的状态树以及它使得轻客户端认证任何关于状态的事情都变得非常简单）
5.transactionsRoot：包含此区块所列的所有交易的树的根节点Hash值
6.receiptsRoot：包含此区块所列的所有交易收据的树的根节点Hash值
7.logsBloom：由日志信息组成的一个Bloom过滤器 （数据结构）
8.difficulty： 此区块的难度级别
9.number：当前区块的计数（创世纪块的区块序号为0，对于每个后续区块，区块序号都增加1）
10.gasLimit：每个区块的当前gas limit
11.gasUsed： 此区块中交易所用的总gas量
12.timestamp：此区块成立时的unix的时间戳
13.extraData：与此区块相关的附加数据
14.mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算
15.nonce：一个Hash值，当与mixHash组合时，证明此区块已经执行了足够的计算
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607201425.png)
注意每个区块是如何包含三个树结构的，三个树结构分别对应：

状态（stateRoot）
交易（transactionsRoot）
收据（receiptsRoot）
这三个树结构就是我们前面讨论的Merkle Patricia树。

另外，上面描述的有几个术语值得说明一下，下面来看一下。

##### 日志
以太坊允许日志可以跟踪各种交易和信息。一个合约可以通过定义“事件”来显示的生成日志。

一个日志的实体包含：

记录器的账户地址
代表本次交易执行的各种事件的一系列主题以及与这些事件相关的任何数据
日志被保存在bloom过滤器 中，过滤器高效的保存了无尽的日志数据。

##### 交易收据

由于被包含在交易收据中的日志信息存储在头中。就像你在商店买东西时收到的收据一样，以太坊为每笔交易都产生一个收据。像你期望的那样，每个收据包含关于交易的特定信息。这些收据包含着：

1.区块序号
2.区块Hash
3.交易Hash
4.当前交易使用了的gas
5.在当前交易执行完之后当前块使用的累计gas
6.执行当前交易时创建的日志
7.等等

##### 区块难度
区块的难度是被用来在验证区块时加强一致性。创世纪区块的难度是131,072，有一个特殊的公式用来计算之后的每个块的难度。如果某个区块比前一个区块验证的更快，以太坊协议就会增加区块的难度。

区块的难度影响nonce，它是在挖矿时必须要使用proof-of-work算法来计算的一个hash值。

区块难度和nonce之间的关系用数学形式表达就是：
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607237530.png)

Hd代表的是难度。

找到符合难度阈值的nonce唯一方法就是使用proof-of-work算法来列举所有的可能性。找到解决方案预期时间与难度成正比—难度越高，找到nonce就越困难，因此验证一个区块也就越难，这又相应地增加了验证新块所需的时间。所以，通过调整区块难度，协议可以调整验证区块所需的时间。

另一方面，如果验证时间变的越来越慢，协议就会降低难度。这样的话，验证时间自我调节以保持恒定的速率—平均每15s一个块。

##### 交易执行
我们已经到了以太坊协议最复杂的部分：交易的执行。假设你发送了一笔交易给以太坊网络处理，将以太坊状态转换成包含你的交易这个过程到底发生了什么？

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607246652.png)

首先，为了可以被执行，所有的交易必须都要符合最基础的一系列要求，包括：
1. 交易必须是正确格式化的RLP。”RLP”代表Recursive Length Prefix，它是一种数据格式，用来编码二进制数据嵌套数组。以太坊就是使用RLP格式序列化对象。
2. 有效的交易签名。
3. 有效的交易序号。回忆一下账户中的nonce就是从此账户发送出去交易的计数。如果有效，那么交易序号一定等于发送账户中的nonce。
4. 交易的gas limit 一定要等于或者大于交易使用的intrinsic gas，intrinsic gas包括：
    ——-1.执行交易预订费用为21,000gas
    ——-2.随交易发送的数据的gas费用（每字节数据或代码为0的费用为4gas，每个非零字节的数据或代码费用为68gas）
    ——-3.如果交易是合约创建交易，还需要额外的32,000gas
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607274072.png)

发送账户余额必须有足够的Ether来支付”前期”gas费用。前期gas费用的计算比较简单：首先，交易的gas limit乘以交易的gas价格得到最大的gas费用。然后，这个最大gas费用被加到从发送方传送给接收方的总值。

![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607309558.png)

如何交易符合上面所说的所有要求，那么我们进行下面步骤。

第一步，我们从发送者的余额中扣除执行的前期费用，并为当前交易将发送者账户中的nonce增加1。此时，我们可以计算剩余的gas，将交易的总gas减去使用的intrinsic gas。
![](http://7fvhfe.com1.z0.glb.clouddn.com/wp-content/uploads/2017/10/201710110607334405.png)

第二步，开始执行交易。在交易执行的整个过程中，以太坊保持跟踪“子状态”。子状态是记录在交易中生成的信息的一种方式，当交易完成时会立即需要这些信息。具体来说，它包含：

1. 自毁集：在交易完成之后会被丢弃的账户集（如果存在的话）
2. 日志系列：虚拟机的代码执行的归档和可检索的检查点
3. 退款余额：交易完成之后需要退还给发送账户的总额。回忆一下我们之前提到的以太坊中的存储需要付费，发送者要是清理了内存就会有退款。以太坊使用退款计数进行跟踪退款余额。退款计数从0开始并且每当合约删除了一些存储中的东西都会进行增加。
    
第三步，交易所需的各种计算开始被处理。

当交易所需的步骤全部处理完成，并假设没有无效状态，通过确定退还给发送者的未使用的gas量，最终的状态也被确定。除了未使用的gas，发送者还会得到上面所说的“退款余额”中退还的一些津贴。
一旦发送者得到退款之后：

1. gas的Ether就会矿工
2. 交易使用的gas会被添加到区块的gas计数中（计数一直记录当前区块中所有交易使用的gas总量，这对于验证区块时是非常有用的）
3. 所有在自毁集中的账户（如果存在的话）都会被删除
最后，我们就有了一个新的状态以及交易创建的一系列日志。

现在我们已经介绍了交易执行的基本知识，让我们再看看合约创建交易和消息通信的一些区别。

##### 合约创建(Contract creation)
回忆一下在以太坊中，有两种账户类型：合约账户和外部拥有账户。当我们说一个交易是“合约创建”，是指交易的目的是创建一个新的合约账户。

为了创建一个新的合约账户，我们使用一个特殊的公式来声明新账户的地址。然后我们使用下面的方法来初始化一个账户：

1.设置nonce为0
2.如果发送者通过交易发送了一定量的Ether作为value，那么设置账户的余额为value
3.将存储设置为0
4.设置合约的codeHash为一个空字符串的Hash值

一旦我们完成了账户的初始化，使用交易发送过来的init code（查看”交易和信息”章节来复习一下init code），实际上就创造了一个账户。init code的执行过程是各种各样的。取决于合约的构造器，可能是更新账户的存储，也可能是创建另一个合约账户，或者发起另一个消息通信等等。

初始化合约的代码被执行之后，会使用gas。交易不允许使用的gas超过剩余gas。如果它使用的gas超过剩余gas，那么就会发生gas不足异(OOG)常并退出。如果一个交易由于gas不足异常而退出，那么状态会立刻恢复到交易前的一个点。发送者也不会获得在gas用完之前所花费的gas。

不过，如果发送者随着交易发送了Ether，即使合约创建失败Ether也会被退回来。

如果初始化代码成功的执行完成，最后的合约创建的花费会被支付。这些是存储成本，与创建的合约代码大小成正比（再一次，没有免费的午餐）。如果没有足够的剩余gas来支付最后的花费，那么交易就会再次宣布gas不足异常并中断退出。

如果所有的都正常进行没有任何异常出现，那么任何剩余的未使用gas都会被退回给原始的交易发送者，现在改变的状态才被允许永久保存。

##### 消息通信(Message calls)

